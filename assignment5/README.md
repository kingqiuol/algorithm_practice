## 1、二叉树

### 1.1、二叉树的特性
* **一颗二叉树有n个元素（n>0），它有n-1条边**
* **一棵二叉树高度为h(h>=0),它至少有h个元素，最多有2^h-1个元素**
* **一颗二叉树有n个元素(n>0),它的高度为n，最小高度为[log2(n+1)]**
* **完全二叉树的一元素编号为i(1<=i<=n)，有以下关系成立**

1. 如果i=1，该元素为二叉树的根。若i>1,则其父节点的编号为i/2;
2. 如果2i>n，则表示该元素无左孩子。否则，其左孩子的编号为2i;
3. 如果2i+1>n，则其元素无右孩子。否则其右孩子的编号为2i+1。

### 1.2、常见二叉树的分类

**1. 二叉树**

二叉树是每个节点最多有两个子树的树结构。

**2. 满二叉树**

一棵深度为k，且有2^k-1个节点的树是满二叉树。

**性质：**

1.如果一颗树深度为h，最大层数为k，且深度与最大层数相同，即k=h;

2.它的叶子数是： 2^(h-1)

3.第k层的结点数是： 2^(k-1)

4.总结点数是： 2^k-1 (2的k次方减一)

5.总节点数一定是奇数。

6.树高：h=log2(n+1)。

![image1](./image/20130909225615687.htm)

**3. 完全二叉树**

若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h 层所有
的结点都连续集中在最左边，这就是完全二叉树。

**性质：**

1.深度为k的完全二叉树，至少有2^(k-1)个节点，至多有2^k-1个节点。

2.树高h=log2n + 1。

![image2](./image/20130909225741093.htm)

## 2、竞赛树

### 2.1、赢者树

我们使用完全二叉树的数组表示赢者树。一颗赢者树有n名选手，需要n-1个内部节点 tree[1:n-1]。选手或者外部节点用数组 player[1:n] 表示，因此 
tree[i] 是数组player的一个索引，类型为int。在赢者树的节点 i 对应比赛中的赢者 tree[i] 。图13-4给出在5个选手的赢者树中，各节点与数组 tree 
和 player 之间的对应关系

![image4](./image/20160801102355432.jpg)

为实现这种对应关系，我们必须能够确定外部节点 player[i]  的父节点 tree[p]。当外部节点的个数为n时，内部节点的个数为n-1。最低层最左端的内部节
点，其编号为s，并且有s=2^log（n-1）。因此，最底层内部节点的个数为n-s，而最底层外部节点的个数lowExt是这个数的2倍。例如，在图13-4中，n=5，
s=4，最底层最左端的内部节点是 tree[4]，这一层的内部节点个数为n-4=1个。最底层外部节点个数lowExt=2，倒数第二层最左端的外部节点编号
是lowExt+1.。令offset=2*s-1。对于任何一个外部节点player[i] ，其父节点tree[p]有一下公式给出：

![image5](./image/20160801102401229.jpg)

赢者树关键的两个操作是初始化和重新组织比赛。为了初始化一个赢者树，我们从右孩纸选手开始，进行他所参加的比赛，而且逐层网上，只要是从右孩纸上升到
比赛节点，就可以进行在该节点的比赛。为此，要从左往右的考察右孩纸选手。在图13-4的树种，我们首先进行选手 player[2] 的比赛，然后进行player[3]
的比赛，最后进行 player[5]的比赛。首先，我们进行选手 player[2] 参加在节点 tree[4]  的比赛，但是接下来，我们不能在上一层节点tree[2]的
比赛，因为tree[4]是左孩纸。然后我们进行选手 player[3] 参加在tree[2] 的比赛，但是接下来不能进行在节点tree[1]的比赛，因为tree[2]是左孩纸。
最后我们进行选手 play[5] 参加的在节点tree[3]的比赛和在节点 tree[1] 的比赛。注意，节点 tree[i] 节点记录的是比赛的赢者。

当选手 thePlayer 的值改变，在从外部节点 player[ thePlayer ] 到根节点 tree[1] 的路径上，一部分或者全部比赛都需要进行重赛。

> **参考链接：** 

[数据结构学习笔记（七）竞赛树](https://blog.csdn.net/baidu_35573762/article/details/52073283)

### 2.2、输者树

## 3、搜索树

**二叉搜索树：** 二叉搜索树是以一棵二叉树来组织，每个节点就是一个对象，包括key、卫星数
据，除此之外还包括一些为了维持树结构所需要的信息：left、right、parent，分别指向左孩
子、右孩子、父节点。其中如果孩子节点或者父节点不存在时，用NULL表示。根节点是树中唯一一个
父节点为NULL的节点。

**性质：**

1、每个元素都有一个关键字，并且任意两个元素的关键字都不同；因此，所有关键字都是唯一的；

2、如果节点的左子树不空，则左子树上所有结点的值均小于等于它的根结点的值；

3、如果节点的右子树不空，则右子树上所有结点的值均大于等于它的根结点的值；

4、任意节点的左、右子树也分别为二叉查找树；

**操作**

*1、插入*

确定该搜索数中是否存在该元素，如果存在直接替换；如果不存在，将该元素插入最终搜索点的左、右
孩子节点中。

*2、删除*

1）**如果删除点为叶子节点** ,直接释放叶子节点；如果该节点为根，则令根为NULL;

2）**如果删除的节点只有一颗非空的子树** ,如果p没有父节点（p为根节点），则p的唯一子树的
根节点成为搜索树的根节点；如果p有父节点pp，则修改pp的指针域，使其指向p唯一的孩子，并释放p;

3）**如果删除的节点p具有两颗非空的子树** ,将该节点元素替换为**左子树的最大元素**或
**右子树的最小元素**，然后将该节点删除。

**注意：** 如何查找左子树的最小值或右子树的最大值？

* 左子树的最大值：沿着右子树的左孩子指针移动，直到指针为NULL。
* 右子树的最小值：沿着左子树的右孩子指针移动，直到指针为NULL。

### 3.1、索引二叉搜索树

**索引二叉搜索树:** 在普通的搜索二叉树的每一个节点中添加一个leftSize域，这个域的值是
该节点左子树元素的个数

> **参考链接：**

[二叉搜索树详解](https://www.jianshu.com/p/227c1b0cac8c)

[带索引的二叉搜索树](https://wenku.baidu.com/view/dcf337a1f8c75fbfc67db23a.html)

## 4、平衡搜索树

各种字典结构的渐近时间性能：
<table>
    <tr>
        <th rowspan="2">方法</th>
        <th colspan="3">最坏情况</th>
        <th colspan="3">平均情况</th>
    </tr>
    <tr>
        <td>搜索</td>
        <td>插入</td>
        <td>删除</td>
        <td>搜索</td>
        <td>插入</td>
        <td>删除</td>
    </tr>
    <tr>
        <td>有序数组</td>
        <td>logn</td>
        <td>n</td>
        <td>n</td>
        <td>logn</td>
        <td>n</td>
        <td>n</td>
    </tr>
    <tr>
        <td>有序链表</td>
        <td>n</td>
        <td>n</td>
        <td>n</td>
        <td>n</td>
        <td>n</td>
        <td>n</td>
    </tr>
    <tr>
        <td>跳表</td>
        <td>n</td>
        <td>n</td>
        <td>n</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
    </tr>
    <tr>
        <td>哈希表</td>
        <td>n</td>
        <td>n</td>
        <td>n</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
    </tr>
    <tr>
        <td>二叉搜索树</td>
        <td>n</td>
        <td>n</td>
        <td>n</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
    </tr>
    <tr>
        <td>AVL树</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
    </tr>
    <tr>
        <td>红黑树</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
    </tr>
    <tr>
        <td>分裂树</td>
        <td>n</td>
        <td>n</td>
        <td>n</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
    </tr>
    <tr>
        <td>B-树</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
    </tr>
</table>

AVL和红-黑树适用于内部存储的运用，B-树适用于外部存储的应用。

在实际运用中，当我们需要实施的操作为按关键字查找、插入和删除操作，这时散列的性能超过平衡
搜索树，此时，优先选择散列。如果关键字按照字典操作，且时间不能超过指定的范围，此时提倡使用
平衡搜索树。对于那些按名次实施查找删除的操作，以及那些不按精确关键字匹配的进行字典操作
（如寻找关键字大于k的最小元素），建议使用平衡搜索树。

对于较小可以在内存中处理的字典，AVL和红-黑树都能提供很好的性能；对于大型字典，必须存储于
磁盘中时则需要度数更大，高度更低的树，如：B-树。

**平衡树:** 最坏的情况下高度为O(logn)的树

### 4.1、AVL树

**


> **参考链接：**

[二叉搜索树详解](https://www.jianshu.com/p/227c1b0cac8c)


### 4.2、红-黑树

> **参考链接：**

[二叉搜索树详解](https://www.jianshu.com/p/227c1b0cac8c)


### 4.3、分裂树

> **参考链接：**

[二叉搜索树详解](https://www.jianshu.com/p/227c1b0cac8c)


### 4.4、B-树

> **参考链接：**

[二叉搜索树详解](https://www.jianshu.com/p/227c1b0cac8c)


## 5、优先级队列
元素出队列的顺序由元素的优先级来确定

### 5.1、堆实现优先级队列
**大（小）根堆：** 每个节点都大于（小于）或等于其子节点的值。

![image3](./image/650075-91f1549ff0c87c15.png)



